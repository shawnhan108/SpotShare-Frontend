{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, createIterable } from '@deck.gl/core';\nimport { fp64, ScenegraphNode, isWebGL2, pbr, log } from '@luma.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { MATRIX_ATTRIBUTES } from '../utils/matrix';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\nvar fp64LowPart = fp64.fp64LowPart;\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar defaultProps = {\n  scenegraph: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  fetch: function (_fetch) {\n    function fetch(_x, _x2) {\n      return _fetch.apply(this, arguments);\n    }\n\n    fetch.toString = function () {\n      return _fetch.toString();\n    };\n\n    return fetch;\n  }(function (url, _ref) {\n    var propName = _ref.propName,\n        layer = _ref.layer;\n\n    if (propName === 'scenegraph') {\n      return load(url, layer.getLoadOptions());\n    }\n\n    return fetch(url).then(function (response) {\n      return response.json();\n    });\n  }),\n  getScene: function getScene(scenegraph) {\n    return scenegraph && scenegraph.scenes ? scenegraph.scenes[0] : scenegraph;\n  },\n  getAnimator: function getAnimator(scenegraph) {\n    return scenegraph && scenegraph.animator;\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  _lighting: 'flat',\n  _imageBasedLightingEnvironment: null,\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  }\n};\n\nvar ScenegraphLayer = function (_Layer) {\n  _inherits(ScenegraphLayer, _Layer);\n\n  function ScenegraphLayer() {\n    _classCallCheck(this, ScenegraphLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScenegraphLayer).apply(this, arguments));\n  }\n\n  _createClass(ScenegraphLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          accessor: 'getPosition',\n          transition: true\n        },\n        instancePositions64xy: {\n          size: 2,\n          accessor: 'getPosition',\n          update: this.calculateInstancePositions64xyLow\n        },\n        instanceColors: {\n          size: 4,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR,\n          transition: true\n        },\n        instanceModelMatrix: MATRIX_ATTRIBUTES\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions64xyLow\",\n    value: function calculateInstancePositions64xyLow(attribute, _ref2) {\n      var startRow = _ref2.startRow,\n          endRow = _ref2.endRow;\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$props = this.props,\n          data = _this$props.data,\n          getPosition = _this$props.getPosition;\n      var value = attribute.value,\n          size = attribute.size;\n      var i = startRow * size;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n          objectInfo.index++;\n          var position = getPosition(point, objectInfo);\n          value[i++] = fp64LowPart(position[0]);\n          value[i++] = fp64LowPart(position[1]);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params) {\n      _get(_getPrototypeOf(ScenegraphLayer.prototype), \"updateState\", this).call(this, params);\n\n      var props = params.props,\n          oldProps = params.oldProps;\n\n      if (props.scenegraph !== oldProps.scenegraph) {\n        var scenegraph = props.getScene(props.scenegraph);\n        var animator = props.getAnimator(props.scenegraph);\n\n        if (scenegraph instanceof ScenegraphNode) {\n          this._deleteScenegraph();\n\n          this._applyAllAttributes(scenegraph);\n\n          this._applyAnimationsProp(scenegraph, animator, props._animations);\n\n          this.setState({\n            scenegraph: scenegraph,\n            animator: animator\n          });\n        } else if (scenegraph !== null) {\n          log.warn('invalid scenegraph:', scenegraph)();\n        }\n      } else if (props._animations !== oldProps._animations) {\n        this._applyAnimationsProp(this.state.scenegraph, this.state.animator, props._animations);\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      this._deleteScenegraph();\n    }\n  }, {\n    key: \"_applyAllAttributes\",\n    value: function _applyAllAttributes(scenegraph) {\n      var _this = this;\n\n      if (this.state.attributesAvailable) {\n        var allAttributes = this.getAttributeManager().getAttributes();\n        scenegraph.traverse(function (model) {\n          _this._setModelAttributes(model.model, allAttributes);\n        });\n      }\n    }\n  }, {\n    key: \"_applyAnimationsProp\",\n    value: function _applyAnimationsProp(scenegraph, animator, animationsProp) {\n      if (!scenegraph || !animator || !animationsProp) {\n        return;\n      }\n\n      var animations = animator.getAnimations();\n      Object.keys(animationsProp).forEach(function (key) {\n        var value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(function (animation) {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          var number = Number(key);\n\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(\"animation \".concat(key, \" not found\"))();\n          }\n        } else {\n          var findResult = animations.find(function (_ref3) {\n            var name = _ref3.name;\n            return name === key;\n          });\n\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(\"animation \".concat(key, \" not found\"))();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_deleteScenegraph\",\n    value: function _deleteScenegraph() {\n      var scenegraph = this.state.scenegraph;\n\n      if (scenegraph instanceof ScenegraphNode) {\n        scenegraph.delete();\n      }\n    }\n  }, {\n    key: \"addVersionToShader\",\n    value: function addVersionToShader(source) {\n      if (isWebGL2(this.context.gl)) {\n        return \"#version 300 es\\n\".concat(source);\n      }\n\n      return source;\n    }\n  }, {\n    key: \"getLoadOptions\",\n    value: function getLoadOptions() {\n      var modules = ['project32', 'picking'];\n      var _this$props2 = this.props,\n          _lighting = _this$props2._lighting,\n          _imageBasedLightingEnvironment = _this$props2._imageBasedLightingEnvironment;\n\n      if (_lighting === 'pbr') {\n        modules.push(pbr);\n      }\n\n      var env = null;\n\n      if (_imageBasedLightingEnvironment) {\n        if (typeof _imageBasedLightingEnvironment === 'function') {\n          env = _imageBasedLightingEnvironment({\n            gl: this.context.gl,\n            layer: this\n          });\n        } else {\n          env = _imageBasedLightingEnvironment;\n        }\n      }\n\n      return {\n        gl: this.context.gl,\n        waitForFullLoad: true,\n        imageBasedLightingEnvironment: env,\n        modelOptions: {\n          vs: this.addVersionToShader(vs),\n          fs: this.addVersionToShader(fs),\n          modules: modules,\n          isInstanced: true\n        },\n        useTangents: false\n      };\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(props) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ScenegraphLayer.prototype), \"updateAttributes\", this).call(this, props);\n\n      this.setState({\n        attributesAvailable: true\n      });\n      if (!this.state.scenegraph) return;\n      var attributeManager = this.getAttributeManager();\n      var changedAttributes = attributeManager.getChangedAttributes({\n        clearChangedFlags: true\n      });\n      this.state.scenegraph.traverse(function (model) {\n        _this2._setModelAttributes(model.model, changedAttributes);\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref4) {\n      var _ref4$moduleParameter = _ref4.moduleParameters,\n          moduleParameters = _ref4$moduleParameter === void 0 ? null : _ref4$moduleParameter,\n          _ref4$parameters = _ref4.parameters,\n          parameters = _ref4$parameters === void 0 ? {} : _ref4$parameters,\n          context = _ref4.context;\n      if (!this.state.scenegraph) return;\n\n      if (this.props._animations && this.state.animator) {\n        this.state.animator.animate(context.animationProps.time);\n      }\n\n      var sizeScale = this.props.sizeScale;\n      var numInstances = this.getNumInstances();\n      this.state.scenegraph.traverse(function (model, _ref5) {\n        var worldMatrix = _ref5.worldMatrix;\n        model.model.setInstanceCount(numInstances);\n        model.updateModuleSettings(moduleParameters);\n        model.draw({\n          parameters: parameters,\n          uniforms: {\n            sizeScale: sizeScale,\n            sceneModelMatrix: worldMatrix,\n            u_Camera: model.model.program.uniforms.project_uCameraPosition\n          }\n        });\n      });\n    }\n  }]);\n\n  return ScenegraphLayer;\n}(Layer);\n\nexport { ScenegraphLayer as default };\nScenegraphLayer.layerName = 'ScenegraphLayer';\nScenegraphLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}