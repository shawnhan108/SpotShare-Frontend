{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { PhongMaterial } from '@luma.gl/core';\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION } from '../utils/aggregation-operation-utils';\nimport { pointToDensityGridData } from '../utils/gpu-grid-aggregation/grid-aggregation-utils';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport GPUGridCellLayer from './gpu-grid-cell-layer';\nimport { pointToDensityGridDataCPU } from './../cpu-grid-layer/grid-aggregator';\nvar defaultMaterial = new PhongMaterial();\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  colorAggregation: 'SUM',\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  elevationAggregation: 'SUM',\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  extruded: false,\n  fp64: false,\n  material: defaultMaterial,\n  gpuAggregation: true\n};\n\nvar GPUGridLayer = function (_CompositeLayer) {\n  _inherits(GPUGridLayer, _CompositeLayer);\n\n  function GPUGridLayer() {\n    _classCallCheck(this, GPUGridLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GPUGridLayer).apply(this, arguments));\n  }\n\n  _createClass(GPUGridLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var isSupported = GPUGridAggregator.isSupported(gl);\n\n      if (!isSupported) {\n        log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n      }\n\n      var options = {\n        id: \"\".concat(this.id, \"-gpu-aggregator\"),\n        shaderCache: this.context.shaderCache\n      };\n      this.state = {\n        gpuGridAggregator: new GPUGridAggregator(gl, options),\n        isSupported: isSupported\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      var aggregationFlags = this.getAggregationFlags(opts);\n\n      if (aggregationFlags) {\n        this.getLayerData(aggregationFlags);\n        this.setState({\n          gridHash: null\n        });\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(GPUGridLayer.prototype), \"finalizeState\", this).call(this);\n\n      this.state.gpuGridAggregator.delete();\n    }\n  }, {\n    key: \"getAggregationFlags\",\n    value: function getAggregationFlags(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var aggregationFlags = null;\n\n      if (!this.state.isSupported) {\n        return false;\n      }\n\n      if (this.isDataChanged({\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      })) {\n        aggregationFlags = Object.assign({}, aggregationFlags, {\n          dataChanged: true\n        });\n      }\n\n      if (oldProps.cellSize !== props.cellSize) {\n        aggregationFlags = Object.assign({}, aggregationFlags, {\n          cellSizeChanged: true\n        });\n      }\n\n      return aggregationFlags;\n    }\n  }, {\n    key: \"isDataChanged\",\n    value: function isDataChanged(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        return true;\n      }\n\n      if (oldProps.gpuAggregation !== props.gpuAggregation) {\n        return true;\n      }\n\n      if (oldProps.colorAggregation !== props.colorAggregation || oldProps.elevationAggregation !== props.elevationAggregation) {\n        return true;\n      }\n\n      if (changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition || changeFlags.updateTriggersChanged.getColorWeight || changeFlags.updateTriggersChanged.getElevationWeight)) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getHashKeyForIndex\",\n    value: function getHashKeyForIndex(index) {\n      var _this$state = this.state,\n          gridSize = _this$state.gridSize,\n          gridOrigin = _this$state.gridOrigin,\n          cellSize = _this$state.cellSize;\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n      var lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n      return \"\".concat(latIdx, \"-\").concat(lonIdx);\n    }\n  }, {\n    key: \"getPositionForIndex\",\n    value: function getPositionForIndex(index) {\n      var _this$state2 = this.state,\n          gridSize = _this$state2.gridSize,\n          gridOrigin = _this$state2.gridOrigin,\n          cellSize = _this$state2.cellSize;\n      var yIndex = Math.floor(index / gridSize[0]);\n      var xIndex = index - yIndex * gridSize[0];\n      var yPos = yIndex * cellSize[1] + gridOrigin[1];\n      var xPos = xIndex * cellSize[0] + gridOrigin[0];\n      return [xPos, yPos];\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n          mode = _ref3.mode;\n      var index = info.index;\n      var object = null;\n\n      if (index >= 0) {\n        var gpuGridAggregator = this.state.gpuGridAggregator;\n        var position = this.getPositionForIndex(index);\n        var colorInfo = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('color')));\n        var elevationInfo = GPUGridAggregator.getAggregationData(Object.assign({\n          pixelIndex: index\n        }, gpuGridAggregator.getData('elevation')));\n        object = {\n          colorValue: colorInfo.cellWeight,\n          elevationValue: elevationInfo.cellWeight,\n          count: colorInfo.cellCount || elevationInfo.cellCount,\n          position: position,\n          totalCount: colorInfo.totalCount || elevationInfo.totalCount\n        };\n\n        if (mode !== 'hover') {\n          var _this$props = this.props,\n              data = _this$props.data,\n              getPosition = _this$props.getPosition;\n          var gridHash = this.state.gridHash;\n\n          if (!gridHash) {\n            var cpuAggregation = pointToDensityGridDataCPU(data, this.props.cellSize, getPosition);\n            gridHash = cpuAggregation.gridHash;\n            this.setState({\n              gridHash: gridHash\n            });\n          }\n\n          var key = this.getHashKeyForIndex(index);\n          var cpuAggregationData = gridHash[key];\n          Object.assign(object, cpuAggregationData);\n        }\n      }\n\n      return Object.assign(info, {\n        picked: Boolean(object),\n        object: object\n      });\n    }\n  }, {\n    key: \"getLayerData\",\n    value: function getLayerData(aggregationFlags) {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          cellSizeMeters = _this$props2.cellSize,\n          getPosition = _this$props2.getPosition,\n          gpuAggregation = _this$props2.gpuAggregation,\n          getColorWeight = _this$props2.getColorWeight,\n          colorAggregation = _this$props2.colorAggregation,\n          getElevationWeight = _this$props2.getElevationWeight,\n          elevationAggregation = _this$props2.elevationAggregation,\n          fp64 = _this$props2.fp64;\n      var weightParams = {\n        color: {\n          getWeight: getColorWeight,\n          operation: AGGREGATION_OPERATION[colorAggregation] || AGGREGATION_OPERATION[defaultProps.colorAggregation],\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true\n        },\n        elevation: {\n          getWeight: getElevationWeight,\n          operation: AGGREGATION_OPERATION[elevationAggregation] || AGGREGATION_OPERATION[defaultProps.elevationAggregation],\n          needMin: true,\n          needMax: true,\n          combineMaxMin: true\n        }\n      };\n\n      var _pointToDensityGridDa = pointToDensityGridData({\n        data: data,\n        cellSizeMeters: cellSizeMeters,\n        getPosition: getPosition,\n        weightParams: weightParams,\n        gpuAggregation: gpuAggregation,\n        gpuGridAggregator: this.state.gpuGridAggregator,\n        boundingBox: this.state.boundingBox,\n        aggregationFlags: aggregationFlags,\n        fp64: fp64\n      }),\n          weights = _pointToDensityGridDa.weights,\n          gridSize = _pointToDensityGridDa.gridSize,\n          gridOrigin = _pointToDensityGridDa.gridOrigin,\n          cellSize = _pointToDensityGridDa.cellSize,\n          boundingBox = _pointToDensityGridDa.boundingBox;\n\n      this.setState({\n        weights: weights,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        cellSize: cellSize,\n        boundingBox: boundingBox\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.isSupported) {\n        return null;\n      }\n\n      var _this$props3 = this.props,\n          elevationScale = _this$props3.elevationScale,\n          fp64 = _this$props3.fp64,\n          extruded = _this$props3.extruded,\n          cellSizeMeters = _this$props3.cellSize,\n          coverage = _this$props3.coverage,\n          material = _this$props3.material,\n          elevationRange = _this$props3.elevationRange,\n          colorDomain = _this$props3.colorDomain,\n          elevationDomain = _this$props3.elevationDomain;\n      var _this$state3 = this.state,\n          weights = _this$state3.weights,\n          gridSize = _this$state3.gridSize,\n          gridOrigin = _this$state3.gridOrigin,\n          cellSize = _this$state3.cellSize;\n      var colorRange = colorRangeToFlatArray(this.props.colorRange, Float32Array, 255);\n      var SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n      return new SubLayerClass({\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        gridOffset: cellSize,\n        colorRange: colorRange,\n        elevationRange: elevationRange,\n        colorDomain: colorDomain,\n        elevationDomain: elevationDomain,\n        fp64: fp64,\n        cellSize: cellSizeMeters,\n        coverage: coverage,\n        material: material,\n        elevationScale: elevationScale,\n        extruded: extruded\n      }, this.getSubLayerProps({\n        id: 'gpu-grid-cell'\n      }), {\n        data: weights,\n        numInstances: gridSize[0] * gridSize[1]\n      });\n    }\n  }]);\n\n  return GPUGridLayer;\n}(CompositeLayer);\n\nexport { GPUGridLayer as default };\nGPUGridLayer.layerName = 'GPUGridLayer';\nGPUGridLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}