{"version":3,"sources":["../../../../src/lib/loader-utils/auto-detect-loader.js"],"names":["normalizeLoader","EXT_PATTERN","autoDetectLoader","data","loaders","url","loader","findLoaderByUrl","findLoaderByExamingInitialData","match","extension","findLoaderByExtension","toLowerCase","loaderExtension","extensions","testText","ArrayBuffer","testBinary","type","Array","isArray","test","byteOffset","tests","some","magic","getMagicString","length","arrayBuffer","byteLength","dataView","DataView","i","String","fromCharCode","getUint8"],"mappings":"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","sourcesContent":["import {normalizeLoader} from './normalize-loader';\n\nconst EXT_PATTERN = /[^.]+$/;\n\n// Find a loader that works for extension/text\n// Search the loaders array argument for a loader that matches extension or text\nexport function autoDetectLoader(data, loaders, {url = ''} = {}) {\n  let loader = null;\n  loader = loader || findLoaderByUrl(loaders, url);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n  return loader;\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url.match(EXT_PATTERN);\n  const extension = match && match[0];\n  const loader = extension && findLoaderByExtension(loaders, extension);\n  return loader;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testText(data, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      if (testBinary(data, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, loader) {\n  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      // Magic bytes check: If `loader.test` is a string or array of strings,\n      // check if binary data starts with one of those strings\n      const byteOffset = 0;\n      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n\n      return tests.some(test => {\n        const magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getMagicString(arrayBuffer, byteOffset = 0, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"],"file":"auto-detect-loader.js"}